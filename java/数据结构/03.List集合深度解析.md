### 目录介绍
- 0.问题答疑部分
- 1.ArrayList
    * 1.1 ArrayList集合特点
    * 1.2 简单去重复数据
    * 1.3 ArrayList的扩容消耗
    * 1.4 Arrays.asList方法后的List可以扩容吗？
    * 1.5 List怎么实现排序？
- 2.Vector
    * 2.1 Vector集合特点
- 3.LinkedList
    * 3.1 LinkedList集合特点
- 4.如何选择合适list
    * 4.1 如何选择合适list
    * 4.2 不同容器类型适合的场景
    * 4.3 list集合读写机制和读写效率
- 5.List集合框架拓展
    * 5.1 Java中list集合框架的设计结构
    * 5.2 List集合性能分析
    * 5.3 List集合并发
    * 5.4 面试之集合中设计算法考察
- 6.思考与总结


### 0.问题答疑部分
- 0.0.1 对比 Vector、ArrayList、LinkedList有何区别？
    - 这三者都是实现集合框架中的 List，也就是所谓的有序集合，因此具体功能也比较近似，比如都提供按照位置进行定位、添加或者删除的操作，都提供迭代器以遍历其内容等。但因为具体的设计区别，在行为、性能、线程安全等方面，表现又有很大不同。
    - Vector 是 Java 早期提供的线程安全的动态数组，如果不需要线程安全，并不建议选择，毕竟同步是有额外开销的。Vector 内部是使用对象数组来保存数据，可以根据需要自动的增加容量，当数组已满时，会创建新的数组，并拷贝原有数组数据。
    - ArrayList 是应用更加广泛的动态数组实现，它本身不是线程安全的，所以性能要好很多。与 Vector 近似，ArrayList 也是可以根据需要调整容量，不过两者的调整逻辑有所区别，Vector 在扩容时会提高 1 倍，而 ArrayList 则是增加 50%。
    - LinkedList 顾名思义是 Java 提供的双向链表，所以它不需要像上面两种那样调整容量，它也不是线程安全的。





### 1.ArrayList
#### 1.1 ArrayList集合特点
- 【支持类型】：只能装入引用对象（基本类型要转换为封装类）
- 【线程是否安全】：线程不安全
- 【底层数据结构】：底层由数组实现（顺序表），因为由顺序表实现，所以会具备顺序表的特点，如：需要声明长度、超出长度时需要进行扩容、不适合频繁的移动删除元素、检索元素快；



#### 1.2 简单去重复数据

```
// ArrayList去除集合中字符串的重复值(字符串的内容相同)
// 1. 定义老的集合对象
ArrayList oldList = new ArrayList() ;
// 2. 添加元素
oldList.add("刘亦菲") ;
oldList.add("朱茵") ;
oldList.add("李冰冰 ") ;
oldList.add("范冰冰") ;
oldList.add("李冰冰 ") ;
// 3. 创建新的集合对象
ArrayList newList = new ArrayList() ;
// 4. 遍历老集合对象
for(int x = 0 ; x < oldList.size() ; x++) {
    // 获取当前遍历的元素
    Object object = oldList.get(x) ;
    // 判断新集合中是否包含当前遍历的元素
    if(!newList.contains(object)) {
        newList.add(object) ;
    }
}
```

#### 1.3 ArrayList的扩容消耗
- 由于ArrayList使用elementData = Arrays.copyOf(elementData, newCapacity);进行扩容，而每次都会重新创建一个newLength长度的数组，所以扩容的空间复杂度为O(n),时间复杂度为O(n)

```
public static <T,U> T[] copyOf(U[] original, int newLength, Class<? extends T[]> newType) {
    T[] copy = ((Object)newType == (Object)Object[].class)
        ? (T[]) new Object[newLength]
        : (T[]) Array.newInstance(newType.getComponentType(), newLength);
    System.arraycopy(original, 0, copy, 0,
                     Math.min(original.length, newLength));
    return copy;
}
```


#### 1.4 Arrays.asList方法后的List可以扩容吗？
- 不能，asList返回的List为只读的。其原因为：asList方法返回的ArrayList是Arrays的一个内部类，并且没有实现add，remove等操作


#### 1.5 List怎么实现排序？
- 实现排序，可以使用自定义排序：list.sort(new Comparator(){...})
- 或者使用Collections进行快速排序：Collections.sort(list)


### 2.Vector
#### 2.1 Vectot集合特点
- 【支持类型】：只能装入引用对象（基本类型要转换为封装类）
- 【线程是否安全】：Vector通过synchronized方法保证线程安全；
- 【底层数据结构】：底层由动态数组实现，特点和ArrayList一样，是一样而不是类似。查询快 , 增删慢
- 常用方法
	* public void addElement(E obj)        添加元素
	* public E elementAt(int index)        根据索引获取元素
	* public Enumeration elements()        使用类似于迭代器 , 作用: 用来遍历Vector集合
- 遍历

```
Enumeration enumeration = vector.elements() ;
// boolean hasMoreElements(): 判断集合中是否存在下一个元素
// E nextElement(): 获取下一个元素
while(enumeration.hasMoreElements()) {
    System.out.println(enumeration.nextElement());
}
```



### 3.LinkedList
#### 3.1 LinkedList集合特点
- 【支持类型】：只能装入引用对象（基本类型要转换为封装类）
- 【线程是否安全】：线程不安全
- 【底层数据结构】：底层实现为链表，具备链表的特点，如：不用声明长度、检索性能较差，但是插入移动删除较快。链表通过Node对象实现



### 4.如何选择合适list
#### 4.1 如何选择合适list
- 对于随机查询与迭代遍历操作，数组比所有的容器都要快。所以在随机访问中一般使用ArrayList。
- LinkedList使用双向链表对元素的增加和删除提供了非常好的支持，而ArrayList执行增加和删除元素需要进行元素位移。
- 对于Vector而已，我们一般都是避免使用。（ArrayList可用通过Collections中的方法转换为线程安全类）
- 将ArrayList当做首选，毕竟对于集合元素而已我们都是进行遍历，只有当程序的性能因为List的频繁插入和删除而降低时，再考虑LinkedList。



#### 4.2 不同容器类型适合的场景
- Vector 和 ArrayList 作为动态数组，其内部元素以数组形式顺序存储的，所以非常适合随机访问的场合。除了尾部插入和删除元素，往往性能会相对较差，比如我们在中间位置插入一个元素，需要移动后续所有元素。
- 而 LinkedList 进行节点插入、删除却要高效得多，但是随机访问性能则要比动态数组慢。


#### 4.3 list集合读写机制和读写效率
- **4.3.1 读写机制**
    - ArrayList在执行插入元素是超过当前数组预定义的最大值时，数组需要扩容，扩容过程需要调用底层System.arraycopy()方法进行大量的数组复制操作；在删除元素时并不会减少数组的容量（如果需要缩小数组容量，可以调用trimToSize()方法）；在查找元素时要遍历数组，对于非null的元素采取equals的方式寻找。
    - LinkedList在插入元素时，须创建一个新的Entry对象，并更新相应元素的前后元素的引用；在查找元素时，需遍历链表；在删除元素时，要遍历链表，找到要删除的元素，然后从链表上将此元素删除即可。
    - Vector与ArrayList仅在插入元素时容量扩充机制不一致。对于Vector，默认创建一个大小为10的Object数组，并将capacityIncrement设置为0；当插入元素数组大小不够时，如果capacityIncrement大于0，则将Object数组的大小扩大为现有size+capacityIncrement；如果capacityIncrement<=0,则将Object数组的大小扩大为现有大小的2倍。




- **4.3.2 读写效率**
    - ArrayList对元素的增加和删除都会引起数组的内存分配空间动态发生变化。因此，对其进行插入和删除速度较慢，但检索速度很快。
    - LinkedList由于基于链表方式存放数据，增加和删除元素的速度较快，但是检索速度较慢。



### 5.List集合框架拓展
#### 5.1 Java中list集合框架的设计结构



#### 5.2 List集合性能分析



#### 5.3 List集合并发



#### 5.4 面试之集合中设计算法考察
- 考察算法不仅仅是如何简单实现，面试官往往会刨根问底，比如哪些是排序是不稳定的呢（快排、堆排），或者思考稳定意味着什么；对不同数据集，各种排序的最好或最差情况；从某个角度如何进一步优化比如空间占用，假设业务场景需要最小辅助空间，这个角度堆排序就比归并优异）等，从简单的了解，到进一步的思考，面试官通常还会观察面试者处理问题和沟通时的思路。



### 6.思考与总结
- 6.1 思考一个应用场景，比如你需要实现一个云计算任务调度系统，希望可以保证 VIP 客户的任务被优先处理，你可以利用哪些数据结构或者标准的集合类型呢？



### 参考博客
- 高手不得不知的Java集合List的细节：https://www.jianshu.com/p/e23e3fb2d326





